"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _debounce = _interopRequireDefault(require("./debounce"));

var _memoize = _interopRequireDefault(require("./memoize"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

var ScrollSpy =
/*#__PURE__*/
function (_React$Component) {
  _inherits(ScrollSpy, _React$Component);

  function ScrollSpy(props, context) {
    var _this;

    _classCallCheck(this, ScrollSpy);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ScrollSpy).call(this, props, context));
    _this.handlePointerOver = (0, _debounce.default)(_this.handlePointerOver.bind(_assertThisInitialized(_assertThisInitialized(_this))), 300);
    _this.handleScroll = _this.handleScroll.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.emitScroll = (0, _memoize.default)(function (initial, fraction, width) {
      _this.props.onScroll && _this.props.onScroll({
        initial: initial,
        fraction: fraction,
        width: width
      });
    });
    return _this;
  }

  _createClass(ScrollSpy, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var target = this.props.target;

      if (target) {
        target.addEventListener('pointerover', this.handlePointerOver, {
          passive: true
        });
        target.addEventListener('scroll', this.handleScroll, {
          passive: true
        });
        this.emitInitialScrollEvent(target);
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.target !== this.props.target) {
        var prevTarget = prevProps.target;
        var target = this.props.target;

        if (prevTarget) {
          prevTarget.removeEventListener('pointerover', this.handlePointerOver);
          prevTarget.removeEventListener('scroll', this.handleScroll);
        }

        if (target) {
          target.addEventListener('pointerover', this.handlePointerOver, {
            passive: true
          });
          target.addEventListener('scroll', this.handleScroll, {
            passive: true
          });
          this.emitInitialScrollEvent(target);
        }
      }
    }
  }, {
    key: "emitInitialScrollEvent",
    value: function emitInitialScrollEvent(target, waited) {
      var _this2 = this;

      if (!waited && target.scrollWidth === target.offsetWidth) {
        // HACK: Chrome 66 will initially say scrollWidth equals to offsetWidth, until some time later
        setTimeout(function () {
          return _this2.emitInitialScrollEvent(target, true);
        });
      }

      this.handleScroll({
        target: target
      }, true);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var target = this.props.target;
      target && target.removeEventListener('scroll', this.handleScroll);
    }
  }, {
    key: "handlePointerOver",
    value: function handlePointerOver() {
      // We need to send "onScroll" because "scrollWidth" might have changed
      // For example, the container resized, the scroll width will be incorrect
      // We will debounce to prevent "pointerOver" calculating too often
      // We will memoize to prevent firing unnecessary "onScroll"
      var target = this.props.target;
      this.handleScroll({
        target: target
      });
    }
  }, {
    key: "handleScroll",
    value: function handleScroll(_ref) {
      var target = _ref.target;
      var initial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var offsetWidth = target.offsetWidth,
          scrollLeft = target.scrollLeft,
          scrollWidth = target.scrollWidth;
      this.emitScroll(initial, "".concat(scrollWidth === offsetWidth ? 0 : scrollLeft / (scrollWidth - offsetWidth) * 100, "%"), "".concat(offsetWidth / scrollWidth * 100, "%"));
    }
  }, {
    key: "render",
    value: function render() {
      return false;
    }
  }]);

  return ScrollSpy;
}(_react.default.Component);

exports.default = ScrollSpy;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9TY3JvbGxTcHkuanMiXSwibmFtZXMiOlsiU2Nyb2xsU3B5IiwicHJvcHMiLCJjb250ZXh0IiwiaGFuZGxlUG9pbnRlck92ZXIiLCJiaW5kIiwiaGFuZGxlU2Nyb2xsIiwiZW1pdFNjcm9sbCIsImluaXRpYWwiLCJmcmFjdGlvbiIsIndpZHRoIiwib25TY3JvbGwiLCJ0YXJnZXQiLCJhZGRFdmVudExpc3RlbmVyIiwicGFzc2l2ZSIsImVtaXRJbml0aWFsU2Nyb2xsRXZlbnQiLCJwcmV2UHJvcHMiLCJwcmV2VGFyZ2V0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIndhaXRlZCIsInNjcm9sbFdpZHRoIiwib2Zmc2V0V2lkdGgiLCJzZXRUaW1lb3V0Iiwic2Nyb2xsTGVmdCIsIlJlYWN0IiwiQ29tcG9uZW50Il0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBRUE7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFFcUJBLFM7Ozs7O0FBQ25CLHFCQUFZQyxLQUFaLEVBQW1CQyxPQUFuQixFQUE0QjtBQUFBOztBQUFBOztBQUMxQixtRkFBTUQsS0FBTixFQUFhQyxPQUFiO0FBRUEsVUFBS0MsaUJBQUwsR0FBeUIsdUJBQVMsTUFBS0EsaUJBQUwsQ0FBdUJDLElBQXZCLHVEQUFULEVBQTRDLEdBQTVDLENBQXpCO0FBQ0EsVUFBS0MsWUFBTCxHQUFvQixNQUFLQSxZQUFMLENBQWtCRCxJQUFsQix1REFBcEI7QUFFQSxVQUFLRSxVQUFMLEdBQWtCLHNCQUFRLFVBQUNDLE9BQUQsRUFBVUMsUUFBVixFQUFvQkMsS0FBcEIsRUFBOEI7QUFDdEQsWUFBS1IsS0FBTCxDQUFXUyxRQUFYLElBQXVCLE1BQUtULEtBQUwsQ0FBV1MsUUFBWCxDQUFvQjtBQUFFSCxRQUFBQSxPQUFPLEVBQVBBLE9BQUY7QUFBV0MsUUFBQUEsUUFBUSxFQUFSQSxRQUFYO0FBQXFCQyxRQUFBQSxLQUFLLEVBQUxBO0FBQXJCLE9BQXBCLENBQXZCO0FBQ0QsS0FGaUIsQ0FBbEI7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bEM7QUFLRDs7OzZCQUVRO0FBQ1AsYUFBTyxLQUFQO0FBQ0Q7Ozs7RUE3RW9DSSxlQUFNQyxTIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IGRlYm91bmNlIGZyb20gJy4vZGVib3VuY2UnO1xuaW1wb3J0IG1lbW9pemUgZnJvbSAnLi9tZW1vaXplJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2Nyb2xsU3B5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpIHtcbiAgICBzdXBlcihwcm9wcywgY29udGV4dCk7XG5cbiAgICB0aGlzLmhhbmRsZVBvaW50ZXJPdmVyID0gZGVib3VuY2UodGhpcy5oYW5kbGVQb2ludGVyT3Zlci5iaW5kKHRoaXMpLCAzMDApO1xuICAgIHRoaXMuaGFuZGxlU2Nyb2xsID0gdGhpcy5oYW5kbGVTY3JvbGwuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuZW1pdFNjcm9sbCA9IG1lbW9pemUoKGluaXRpYWwsIGZyYWN0aW9uLCB3aWR0aCkgPT4ge1xuICAgICAgdGhpcy5wcm9wcy5vblNjcm9sbCAmJiB0aGlzLnByb3BzLm9uU2Nyb2xsKHsgaW5pdGlhbCwgZnJhY3Rpb24sIHdpZHRoIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgY29uc3QgeyB0YXJnZXQgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm92ZXInLCB0aGlzLmhhbmRsZVBvaW50ZXJPdmVyLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVTY3JvbGwsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgIHRoaXMuZW1pdEluaXRpYWxTY3JvbGxFdmVudCh0YXJnZXQpO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICBpZiAocHJldlByb3BzLnRhcmdldCAhPT0gdGhpcy5wcm9wcy50YXJnZXQpIHtcbiAgICAgIGNvbnN0IHsgdGFyZ2V0OiBwcmV2VGFyZ2V0IH0gPSBwcmV2UHJvcHM7XG4gICAgICBjb25zdCB7IHRhcmdldCB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgaWYgKHByZXZUYXJnZXQpIHtcbiAgICAgICAgcHJldlRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyb3ZlcicsIHRoaXMuaGFuZGxlUG9pbnRlck92ZXIpO1xuICAgICAgICBwcmV2VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm92ZXInLCB0aGlzLmhhbmRsZVBvaW50ZXJPdmVyLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmhhbmRsZVNjcm9sbCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLmVtaXRJbml0aWFsU2Nyb2xsRXZlbnQodGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbWl0SW5pdGlhbFNjcm9sbEV2ZW50KHRhcmdldCwgd2FpdGVkKSB7XG4gICAgaWYgKCF3YWl0ZWQgJiYgdGFyZ2V0LnNjcm9sbFdpZHRoID09PSB0YXJnZXQub2Zmc2V0V2lkdGgpIHtcbiAgICAgIC8vIEhBQ0s6IENocm9tZSA2NiB3aWxsIGluaXRpYWxseSBzYXkgc2Nyb2xsV2lkdGggZXF1YWxzIHRvIG9mZnNldFdpZHRoLCB1bnRpbCBzb21lIHRpbWUgbGF0ZXJcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5lbWl0SW5pdGlhbFNjcm9sbEV2ZW50KHRhcmdldCwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIHRoaXMuaGFuZGxlU2Nyb2xsKHsgdGFyZ2V0IH0sIHRydWUpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgY29uc3QgeyB0YXJnZXQgfSA9IHRoaXMucHJvcHM7XG5cbiAgICB0YXJnZXQgJiYgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsKTtcbiAgfVxuXG4gIGhhbmRsZVBvaW50ZXJPdmVyKCkge1xuICAgIC8vIFdlIG5lZWQgdG8gc2VuZCBcIm9uU2Nyb2xsXCIgYmVjYXVzZSBcInNjcm9sbFdpZHRoXCIgbWlnaHQgaGF2ZSBjaGFuZ2VkXG4gICAgLy8gRm9yIGV4YW1wbGUsIHRoZSBjb250YWluZXIgcmVzaXplZCwgdGhlIHNjcm9sbCB3aWR0aCB3aWxsIGJlIGluY29ycmVjdFxuICAgIC8vIFdlIHdpbGwgZGVib3VuY2UgdG8gcHJldmVudCBcInBvaW50ZXJPdmVyXCIgY2FsY3VsYXRpbmcgdG9vIG9mdGVuXG4gICAgLy8gV2Ugd2lsbCBtZW1vaXplIHRvIHByZXZlbnQgZmlyaW5nIHVubmVjZXNzYXJ5IFwib25TY3JvbGxcIlxuICAgIGNvbnN0IHsgdGFyZ2V0IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgdGhpcy5oYW5kbGVTY3JvbGwoeyB0YXJnZXQgfSk7XG4gIH1cblxuICBoYW5kbGVTY3JvbGwoeyB0YXJnZXQgfSwgaW5pdGlhbCA9IGZhbHNlKSB7XG4gICAgY29uc3QgeyBvZmZzZXRXaWR0aCwgc2Nyb2xsTGVmdCwgc2Nyb2xsV2lkdGggfSA9IHRhcmdldDtcblxuICAgIHRoaXMuZW1pdFNjcm9sbChcbiAgICAgIGluaXRpYWwsXG4gICAgICBgJHsgc2Nyb2xsV2lkdGggPT09IG9mZnNldFdpZHRoID8gMCA6IHNjcm9sbExlZnQgLyAoc2Nyb2xsV2lkdGggLSBvZmZzZXRXaWR0aCkgKiAxMDAgfSVgLFxuICAgICAgYCR7IG9mZnNldFdpZHRoIC8gc2Nyb2xsV2lkdGggKiAxMDAgfSVgXG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiJdfQ==